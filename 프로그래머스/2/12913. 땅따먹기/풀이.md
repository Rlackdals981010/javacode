## 1. 그리디
- 열에서 최댓값 (내 아래 제외)를 하나씩 찾는다.
- 찾은걸 다 더한다 
- 종료
일단 아주 단순하게 이렇게 접근했다.

하지만 이 방법은 최선의 값을 제공하지 못한다.

예를 들면 1|1|1|3과 1|1|1|8 이렇게 있다고 가정한다. 
그리디이기 때문에 0열에선 무조건 3을 고르게 되고 그 다음 열에선 1을 고르게 된다.
전체 값은 4가 되는데, 이건 누가봐도 답은 1+8로 9 이다. 즉, 그리디로 접근하면 안되는 문제

## 2. DP
그리디처럼 접근하면 안되는것을 알았기 때문에 모든 경로를 탐색해야 하나? 라는 생각이 들 수 있다.
하지만 행이 개수가 커지면 커질수록 계산량이 급증하기 때문에 현실성이 떨어진다. 

이 문제의 특징은 전 선택이 이후 선택에 영향을 끼친다는 걸 생각한다면 DP가 적절한 접근법이 된다.
방법은 다음과 같다.
1. 최초열은 건너 뛴다.
2. land[1][i]=land[1][i] + land[0]열에서 i행을 제외한 값중 최댓값
3. 2를 반복
4. 마지막 열 계산 종료 후 그 중 최댓값을 반환
   
이렇게 하면 시간복잡도 O(N)으로 나쁘지 않게 결과가 나온다.
